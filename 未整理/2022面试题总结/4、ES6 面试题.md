---
标题: 4、ES6 面试题
描述: null
封面: null
uid: 20240203221855940
aliases: []
tags:
  - 面试题
cssclasses: null
创建时间: 2023-05-07T17:52:33.000Z
更新时间: 2024-01-22T16:57:28.000Z
---

# 4、ES6 面试题

## 四、ES6 面试题

### 1、ES6 新特性

  1. 模块化开发
  2. 箭头函数
  3. 函数参数默认值
  4. 模板字符串
  5. 解构赋值
  6. 对象属性简写
  7. Promise
  8. let 与 const
  9. class 类
  10. 扩展运算符
  11. 新增了数组、字符串、对象的方法
  12. for…of

### 2、let Const Var 的区别

```
1、var声明的变量会挂载到window上，而let和const声明的变量不会。
2、var声明变量存在变量声明提升，let和const不存在变量声明提升。
3、let和const声明的变量有块作用域,var没有
4、同一作用域下let和const不能声明同名变量，而var可以。
5、let和const声明的变量存在 暂时性死区，var没有。
6、const声明变量的时候必须赋初始值,而值不能改变。
```

### 3、数组和字符串常用方法

| **方法**     | **含义**                                                     | **发音/邪音** |
| ------------ | ------------------------------------------------------------ | ------------- |
| filter()     | 对数组中的每个元素执行相同的函数，将结果组合成一个新数组。|               |
| map()        | 主要用于对每个数组里面的元素执行相同的函数来创建新的数组     |               |
| some()       | 方法用于检测数组中的元素是否满足指定条件，返回值为布尔类型   |               |
| every()      | 主要用于检查数组中每个元素是否符合函数的条件，如果其中有一个不符合，则返回 false |               |
| reduce()     | 求和操作，主要是对数组中的每个元素执行函数，生成一个值。|               |
| flat()       | 将多维数组转成一维数组                                       |               |
| find()       | 查找数组第一个符合条件的元素                                 |               |
| findIndex()  | 查找数组第一个符合条件的元素的下标                           |               |
| from()       | 将类数组转真正的数组                                         |               |
| **方法**     | **含义**                                                     | **发音/邪音** |
| padStart()   | 用于头部补全                                                 |               |
| padEnd()     | 用于尾部补全                                                 |               |
| trimStart()  | 消除字符串头部的空格                                         |               |
| trimEnd()    | 消除尾部的空格 `                                              |               |
| trim()       | 方法用于删除字符串的头尾空白符                               |               |
| repeat()     | 表示将原字符串重复`n`次                                      |               |
| startsWith() | 返回布尔值，表示参数字符串是否在原字符串的头部。|               |
| endsWith()   | 返回布尔值，表示参数字符串是否在原字符串的尾部。|               |
| includes()   | 返回布尔值，表示是否找到了参数字符串。|               |

### 4、深拷贝和浅拷贝

```
都是引用数据类型来说的，基本数据类型没有深拷贝和浅拷贝一说
浅拷贝\深拷贝
  浅复制只复制一层对象的属性，而深复制则递归复制了所有层级
一、对象的深浅拷贝
深拷贝
1、原生实现
function deepCopy(p,c){
    var i;
    c = c||{};
    for(i in p){
        if(p.hasOwnProperty(i)){
            if(typeof(p[i])==="object"){
                c[i] = Array.isArray(p[i])?[]:{};
                deepCopy(p[i],c[i]);
            }else{
                c[i] = p[i];
           }
        }
    }
    return c;
}

2、使用 JSON 全局对象的 parse 和 stringify 方法来实现深复制
    function jsonClone(obj) {
        return JSON.parse(JSON.stringify(obj));
    }
    var clone = jsonClone({ a:1 });
 (https://www.cnblogs.com/kongxy/p/4618173.html)
 对象的属性分为可枚举和不可枚举之分，它们是由属性的enumerable值决定的。可枚举性决定了这个属性能否被for…in查找遍历到。for...in遍历可枚举的属性和原型链上的可枚举的属性。
这种方法有一个缺点就是只能复制对象中的可枚举属性，其他属性不可复制，例如function。这种简单粗暴的方式有局限性，当值为undefined、function、symbol会在转换过程中被忽略。

这时可以采用如下方法：
function getType(obj) {
  //tostring会返回对应不同的标签的构造函数
  var toString = Object.prototype.toString;
  var map = {
    '[object Boolean]'  : 'boolean',
    '[object Number]'   : 'number',
    '[object String]'   : 'string',
    '[object Function]' : 'function',
    '[object Array]'    : 'array',
    '[object Date]'     : 'date',
    '[object RegExp]'   : 'regExp',
    '[object Undefined]': 'undefined',
    '[object Null]'     : 'null',
    '[object Object]'   : 'object'
  };
  if(obj instanceof Element) {
    return 'element';
  }
  return map[toString.call(obj)];
}

function deepCopy(obj) {
  var type = getType(obj);
  var obj;
  if(type === 'array'){
    obj = [];
  } else if(type === 'object'){
    obj = {};
  } else {
    //不再具有下一层次
    return obj;
  }
  if(type === 'array'){
    for(var i = 0, len = obj.length; i < len; i++){
      obj.push(deepCopy(obj[i]));
    }
  } else if(type === 'object'){
    for(var key in obj){
      obj[key] = deepCopy(obj[key]);
    }
  }
  return obj;
}

3、$.extend(),设置为true是深拷贝
var x = {
    a: 1,
    b: { f: { g: 1 } },
    c: [ 1, 2, 3 ]
};

var y = $.extend({}, x),          //shallow copy
    z = $.extend(true, {}, x);    //deep copy

y.b.f === x.b.f       // true
z.b.f === x.b.f       // false

4、Object.assign(...)

对象的浅拷贝
1、自己封装函数实现
 var obj = { a:1, arr: [2,3] };
 var shallowObj = shallowCopy(obj);

function shallowCopy(src) {
  var dst = {};
  for (var prop in src) {
    if (src.hasOwnProperty(prop)) {
      dst[prop] = src[prop];
    }
  }
  return dst;
}
2、直接赋值
  var obj = {a:1};
  var obj1 = obj;
二、数组的深浅拷贝
浅拷贝
1、直接赋值
  var arr = [12,34,343];
  var arr1 = arr;
2、自己封装函数实现

深拷贝
1、自己封装函数实现
2、slice()
// 当数组里面的值是基本数据类型，比如String，Number，Boolean时，属于深拷贝
// 当数组里面的值是引用数据类型，比如Object，Array时，属于浅拷贝
3、concat()
// 当数组里面的值是基本数据类型，比如String，Number，Boolean时，属于深拷贝
4、使用扩展运算符实现深拷贝
// 当value是基本数据类型，比如String，Number，Boolean时，是可以使用拓展运算符进行深拷贝的
// 当value是引用类型的值，比如Object，Array，引用类型进行深拷贝也只是拷贝了引用地址，所以属于浅拷贝
```

### 5、箭头函数和普通函数的区别

```
区别：
  1、语法不同。
  2、箭头函数是匿名函数，不能作为构造函数，不能使用new。
  3、箭头函数不能绑定arguments，取而代之用rest参数...解决。
  4、箭头函数没有原型属性。
  5、箭头函数不绑定this，会捕获其所在的上下文的this值，作为自己的this值。
  6、箭头函数无法使用 call（）或 apply（）来改变其运行的作用域
  7、箭头函数不能当做Generator函数,不能使用yield关键字.
```

### 6、说说对 promise 的理解

```
Promise是异步编程的一种解决方案，主要解决由于异步请求的多层嵌套造成的回调地狱问题。
解决异步编程的方案：async await  generator  promise
Promise有三个状态和两个过程
  三个状态：pending（初始状态）、fulfilled（成功状态）、rejected（失败状态）；

  两个过程：pending==>fulfilled的过程和pending==>rejected的过程。
  缺点：promise的状态一旦改变则不会再变，是不可逆的,无法阻止状态的改变

  方法：Promise是一个构造函数，自身有all、race、reject、resolve这几个方法，原型上有then和catch方法，让异步代码像同步一样执行。


  all方法是：只有所有的promise对象都成功了，就会调then方法，如果有一个是失败的就会调catch方法
  race方法是：如果有一个成功的就会调then方法，如果第一个是失败的就会调catch方法

  什么时候使用all方法：比如：当一个页面有多个ajax请求，想请求结果都成功之后再处理结果。

js他是单线程的，但是它分为同步任务和异步任务，同步任务会放到主线程中去执行，

在ES6中由于增加了promise，所以在异步任务中又分为宏任务和微任务
宏任务：setTimeout、setInterval、requestAnimationFrame
  1、宏任务所处的任务队列就是宏任务队列
  2、第一个宏任务队列中只有一个任务：执行主线程的js代码
  3、宏任务队列可以有多个
  4、当宏任务队列中的任务全部执行完会查看是否有位任务队列，如果有先执行微任务中的所有任务，如果没有就查看是否有宏任务
微任务：promise.then(回调)   process.nexttick(  )
  1、微任务所处的队列就是微任务队列
  2、只有一个微任务队列
  3、在上一个宏任务队列执行完毕后执行，如果有为任务队列就会执行微任务中的所有任务。
    首先在宏任务的队列中选取出第一个任务，执行完毕后取出为任务队列中的所有任务顺序执行，之后再取出宏任务，周而复始，直至两个队列的任务都取完。


    setTimeout(function(){
            console.log(1);
        },0);
        new Promise(function(a,b){
            console.log(2);
            for(var i=0;i<10;i++){
                i==9&&a();
            }
            console.log(3)
        }).then(function(){
            console.log(4)
        });
        console.log(5);

  正确输出顺序为：2，3，5，4，1；

  微任务先执行，宏任务后执行
```

### 7、for In 和 for Of 的区别

```
for。。。in的特点：
    1.index索引为字符串型数字，不能直接进行几何运算。
    2.遍历顺序有可能不是按照实际数组的内部顺序。
    3.使用for in会遍历数组所有的可枚举属性，包括原型。所以for in更适合遍历对象，不要使用for in遍历数组。
    对象的遍历（for...in..  keys() values() entries()）
for…of的特点：
    for..of适用遍历数/数组对象/字符串/map/set等拥有迭代器对象的集合.但是不能遍历对象,因为对象没有迭代器.与forEach()不同的是，它可以正确响应break、continue和return语句
    for-of循环不支持普通对象，如果要迭代一个对象的属性，可以用for-in循环（这也是它的本职工作）或内建的Object.keys()方法

forEach更多的用来遍历数组

for in 一般常用来遍历对象或json

for of数组对象都可以遍历，遍历对象需要通过和Object.keys()

for in循环出的是key，for of循环出的是value

```

### 8、forEach() 和 map() 和 every() 和 some() 和 filter() 的区别

```
首先forEach、map、filter、every,some都是遍历数组的方法，都是用来遍历数组。
forEach，没有返回值
  不能响应return、break
map：返回值为新的数组
  按照原数组的元素顺序依次处理元素，返回一个处理后的新数组，数组元素是值类型则原数组不变，数组元素为引用类型，则原数组改变
filter：返回值为新的数组
  过滤指定数组中所有符合条件的元素，返回一个新数组，原数组不变
some：返回值为boolean类型
  用于检测数组中的元素是否满足指定条件，如果有一个符合条件的就返回true，如果没有符合条件的就返回false，原数组不变

every:返回值为boolean类型
  every用于检测数组中的元素是否满足指定条件，所有元素都符合条件才返回true，如果没有符合条件的返回    false，原数组不变。
```

### 9、模块化开发 (export 与 export default 的区别)

```
1、export与export default均可用于导出常量、函数、文件、模块等
2、你可以在其它文件或模块中通过import+(常量 | 函数 | 文件 | 模块)名的方式，将其导入，以便能够对其进行使用
3、在一个文件或模块中，export、import可以有多个，export default仅有一个
4、通过export方式导出，在导入时要加{ }，export default则不需要
5、export命令对外接口是有名称的且import命令从模块导入的变量名与被导入模块对外接口的名称相同，而export default命令对外输出的变量名可以是任意的，并且这时import命令后面，不使用大括号。
6、export default命令用于指定模块的默认输出。显然，一个模块只能有一个默认输出，因此export default命令只能使用一次。所以，import命令后面才不用加大括号，因为只可能唯一对应export default命令
```
